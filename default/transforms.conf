[demultiplex_datetime]
INGEST_EVAL= _time=case(isnotnull(strptime(_raw, "%c")), strptime(_raw, "%c"), isnotnull(strptime(_raw, "%H:%M:%S %y-%m-%d")),strptime(_raw, "%H:%M:%S %y-%m-%d"), isnotnull(strptime(_raw, "%Y-%m-%d %H:%M:%S")), strptime(_raw, "%Y-%m-%d %H:%M:%S"))

# use regex replace to pop out the date form the source, append on the first 10 chars from _raw and then run through strftime.
# if the eval fails to execute, CURRENT time will be kept
[construct_compound_date]
INGEST_EVAL= _time=strptime(replace(source,".*/(20\d\d\-\d\d\-\d\d)\.log","\1").substr(_raw,0,10),"%Y-%m-%d%H:%M:%S"), my_date:=null() 

[add_raw_length_to_meta_field]
INGEST_EVAL= event_length=len(_raw)

[drop_useless_fields]
INGEST_EVAL= repeated_field:=null(), random_nonsense:=null(), long_payload:=null()

####

[drop_header]
# the header field form a Splunk CSV export starts with the first row being named after the header _raw. We want to drop these
INGEST_EVAL = queue=if(_raw="\"_raw\"","nullQueue", queue)

[extract_metadata_copy_to_meta]
# We use REGEX to pop out the values for index, host, sourcetype & source, we then write them to tempory variables in _meta.
# We assume that % is not found in the primary keys to optimize the REGEX
SOURCE_KEY=_raw
WRITE_META = true
REGEX = ^"\d+(?:\.\d+)?%%%([^%]+)%%%([^%]+)%%%([^%]+)%%%([^%]+)%%%
FORMAT = my_index::"$1" my_host::"$2" my_source::"$3" my_sourcetype::"$4"

[reassign_meta_to_metadata]
# copy the temporary user defined fields into the primary metadata locations and then delete the temporary fields
INGEST_EVAL = host:=my_host, source:=my_source, index:=my_index, sourcetype:=my_sourcetype, my_host:=null(), my_source=null(), my_index:=null(), my_sourcetype:=null()

[remove_metadata_from_raw]
# extract the _raw field from the protocol and write back to _raw
INGEST_EVAL = _raw=replace(_raw, "^[^%]+%%%(?:[^%]+)%%%(?:[^%]+)%%%(?:[^%]+)%%%(?:[^%]+)%%%(.*)\"","\1")


[copy_meta_to_raw]
SOURCE_KEY = _meta
DEST_KEY = _raw
REGEX = (.*)
FORMAT = $1 ghj

# this regex finds single quoted attribute value pairs, ie the form a=b, and appends them to _meta
[regex_extract_unquoted_av_pairs]
SOURCE_KEY = _raw
REGEX = \s([a-zA-Z][a-zA-Z0-9_-]+)=([^\s"',]+)
REPEAT_MATCH=true
FORMAT = $1::"$2"
WRITE_META = true

# this regex finds single quoted attribute value pairs, ie the form a='b', and appends them to _meta
[regex_extract_single_quoted_av_pairs]
SOURCE_KEY = _raw
REGEX = \s([a-zA-Z0-9_-]+)='([^']+)'
REPEAT_MATCH=true
FORMAT = $1::"$2"
WRITE_META = true

# this regex finds single quoted attribute value pairs, ie the form a="b", and appends them to _meta
[regex_extract_doubled_quoted_av_pairs]
SOURCE_KEY = _raw
REGEX = \s([a-zA-Z][a-zA-Z0-9_-]+)="([^"]+)"
REPEAT_MATCH=true
FORMAT = $1::"$2" 
WRITE_META = true

[override_time]
INGEST_EVAL = parsed_time=_time, _time=strptime(substr(_raw,0,19),"%Y-%m-%d %H:%M:%S")

[extract_email_password]
SOURCE_KEY = _raw
WRITE_META = true
REGEX = email_address=(\S+@\S+) password="([^"]+)"
FORMAT = email_address::"\1" password="\2"

[encode_fields]
INGEST_EVAL = email_encoded=sha1(email_address), password=sha1(password)