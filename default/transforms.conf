################################
# Conflicting datetime formats
################################

#  This transform tests three different date time formats and selects the first match
[demultiplex_datetime]
INGEST_EVAL= _time=case(isnotnull(strptime(_raw, "%c")), strptime(_raw, "%c"), isnotnull(strptime(_raw, "%H:%M:%S %y-%m-%d")),strptime(_raw, "%H:%M:%S %y-%m-%d"), isnotnull(strptime(_raw, "%Y-%m-%d %H:%M:%S")), strptime(_raw, "%Y-%m-%d %H:%M:%S"))

# use regex replace to pop out the date form the source, append on the first 10 chars from _raw and then run through strftime.
# if the eval fails to execute, CURRENT time will be kept
[construct_compound_date]
INGEST_EVAL= _time=strptime(replace(source,".*/(20\d\d\-\d\d\-\d\d)\.log","\1").substr(_raw,0,10),"%Y-%m-%d%H:%M:%S"), my_date:=null() 

# add the length of the _raw string to the event, this needs to be the last transform so we don't change the
# length of _raw again once the value has been computed
[add_raw_length_to_meta_field]
INGEST_EVAL= event_length=len(_raw)

# To drop a field from _meta we need to overwrite any previous value using the := assignment option
[drop_useless_columns]
INGEST_EVAL= time:=null(), repeated_field:=null(), random_nonsense:=null(), long_payload:=null()

# To drop a field from _meta we need to overwrite any previous value using the := assignment option
[drop_useless_time_fields]
INGEST_EVAL= timestartpos:=null(), timeendpos:=null(), date_second:=null(), date_hour:=null(), date_minute:=null(), date_year:=null(), date_month:=null(), date_mday:=null(),  date_wday:=null(), date_zone:=null()

# the header field form a Splunk CSV export starts with the first row being named after the header _raw. We want to drop these
[drop_header]
INGEST_EVAL = queue=if(_raw="\"_raw\"","nullQueue", queue)

# We use REGEX to pop out the values for index, host, sourcetype & source, we then write them to tempory variables in _meta.
# We assume that % is not found in the primary keys to optimize the REGEX
[extract_metadata_copy_to_meta]
SOURCE_KEY=_raw
WRITE_META = true
REGEX = ^"\d+(?:\.\d+)?%%%([^%]+)%%%([^%]+)%%%([^%]+)%%%([^%]+)%%%
FORMAT = my_index::"$1" my_host::"$2" my_source::"$3" my_sourcetype::"$4"

# copy the temporary user defined fields into the primary metadata locations and then delete the temporary fields
[reassign_meta_to_metadata]
INGEST_EVAL = host:=my_host, source:=my_source, index:=my_index, sourcetype:=my_sourcetype, my_host:=null(), my_source=null(), my_index:=null(), my_sourcetype:=null()

# extract the _raw field from the protocol and write back to _raw
[remove_metadata_from_raw]
INGEST_EVAL = _raw=replace(_raw, "^[^%]+%%%(?:[^%]+)%%%(?:[^%]+)%%%(?:[^%]+)%%%(?:[^%]+)%%%(.*)","\1")

# debug function that copies the contents of the _meta field into the _raw field so we can see what is being routed to indexing
[copy_meta_to_raw]
SOURCE_KEY = _meta
DEST_KEY = _raw
REGEX = (.*)
FORMAT = $1

# this regex finds single quoted attribute value pairs, ie the form a=b, and appends them to _meta
[regex_extract_unquoted_av_pairs]
SOURCE_KEY = _raw
REGEX = \s([a-zA-Z][a-zA-Z0-9_-]+)=([^\s"',]+)
REPEAT_MATCH=true
FORMAT = $1::"$2"
WRITE_META = true

# this regex finds single quoted attribute value pairs, ie the form a='b', and appends them to _meta
[regex_extract_single_quoted_av_pairs]
SOURCE_KEY = _raw
REGEX = \s([a-zA-Z0-9_-]+)='([^']+)'
REPEAT_MATCH=true
FORMAT = $1::"$2"
WRITE_META = true

# this regex finds single quoted attribute value pairs, ie the form a="b", and appends them to _meta
[regex_extract_doubled_quoted_av_pairs]
SOURCE_KEY = _raw
REGEX = \s([a-zA-Z][a-zA-Z0-9_-]+)="([^"]+)"
REPEAT_MATCH=true
FORMAT = $1::"$2" 
WRITE_META = true

[override_time]
INGEST_EVAL = parsed_time=_time, _time=strptime(substr(_raw,0,19),"%Y-%m-%d %H:%M:%S")

[extract_email_password]
SOURCE_KEY = _raw
WRITE_META = true
REGEX = email_address=(\S+@\S+) password="([^"]+)"
FORMAT = email_address::"\1" password="\2"

[encode_fields]
INGEST_EVAL = email_encoded=sha1(email_address), password=sha1(password)