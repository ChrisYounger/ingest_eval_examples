[demultiplex_datetime]
INGEST_EVAL= _time=case(isnotnull(strptime(_raw, "%c")), strptime(_raw, "%c"), isnotnull(strptime(_raw, "%H:%M:%S %y-%m-%d")),strptime(_raw, "%H:%M:%S %y-%m-%d"), isnotnull(strptime(_raw, "%Y-%m-%d %H:%M:%S")), strptime(_raw, "%Y-%m-%d %H:%M:%S"))

# use regex replace to pop out the date form the source, append on the first 10 chars from _raw and then run through strftime.
# if the eval fails to execute, CURRENT time will be kept
[construct_compound_date]
INGEST_EVAL= _time=strptime(replace(source,".*/(20\d\d\-\d\d\-\d\d)\.log","\1").substr(_raw,0,10),"%Y-%m-%d%H:%M:%S"), my_date:=null() 

[add_raw_length_to_meta_field]
INGEST_EVAL= event_length=len(_raw)

[drop_useless_fields]
INGEST_EVAL= repeated_field:=null(), random_nonsense:=null(), long_payload:=null()

####

[drop_header]
# the header field form a Splunk CSV export starts with the first row being named after the header _raw. We want to drop these
INGEST_EVAL = queue=if(_raw="\"_raw\"","nullQueue", queue)

[extract_metadata_copy_to_meta]
# We use REGEX to pop out the values for index, host, sourcetype & source, we then write them to tempory variables in _meta.
# We assume that % is not found in the primary keys to optimize the REGEX
SOURCE_KEY=_raw
WRITE_META = true
REGEX = ^"\d+(?:\.\d+)?%%%([^%]+)%%%([^%]+)%%%([^%]+)%%%([^%]+)%%%
FORMAT = my_index::"$1" my_host::"$2" my_source::"$3" my_sourcetype::"$4"

[reassign_meta_to_metadata]
# copy the temporary user defined fields into the primary metadata locations and then delete the temporary fields
INGEST_EVAL = host:=my_host, source:=my_source, index:=my_index, sourcetype:=my_sourcetype, my_host:=null(), my_source=null(), my_index:=null(), my_sourcetype:=null()

[remove_metadata_from_raw]
# extract the _raw field from the protocol and write back to _raw
INGEST_EVAL = _raw=replace(_raw, "^[^%]+%%%(?:[^%]+)%%%(?:[^%]+)%%%(?:[^%]+)%%%(?:[^%]+)%%%(.*)\"","\1")


[copy_meta_to_raw]
SOURCE_KEY = _meta
DEST_KEY = _raw
REGEX = (.*)
FORMAT = $1 ghj

# this will clone the event for future processing
[v_hash_make_clone]
REGEX = (.*)
CLONE_SOURCETYPE = v:email:data:reference_map

# this will re-write raw to replace email with sha256 hash
[v_hash_make_mask]
INGEST_EVAL = email_hash=sha256(replace(_raw, "^(.*)email=(\S+)(.*)$", "\2")), _raw=replace(_raw, "^(.*email)=(\S+)(.*)$", "\1=".email_hash."\3")

# this transform routes data, and emits reference map _raw
[v_hash_make_map_reference]
INGEST_EVAL = queue=if(match(_raw, "email="), "indexQueue", "nullQueue"), index=vsecure, email_hash=sha256(replace(_raw, "^(.*)email=(\S+)(.*)$", "\2")), _raw="hash=\"".email_hash."\" email=\"".replace(_raw, "^(.*)email=(\S+)(.*)$", "\2")."\""
